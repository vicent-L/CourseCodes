对于不同 GC 和堆内存的总结

## 串行垃圾回收

分别测试了xms,xmx从 256MB >512MB > 2G>4G>8G  使用不通垃圾回收器下创建对象数量以及young gc ,full gc时间大小对比,

执行以下命令,Xms设置与-Xmx相同，以避免每次垃圾回收后JVM重新分配内存

```java
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms256m -Xmx256m -XX:+UseSerialGC GCLogAnalysis
```

最后抛出**oom异常**Exception in thread "main" java.lang.OutOfMemoryError: Java heap space

由日志可以看出young gc大约在10-15ms左右，老年代gc时间大概在25ms左右,发生full gc的次数特别多,多达30次，fullGC对垃圾回收几乎没有作用

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms512m -Xmx512m -XX:+UseSerialGC GCLogAnalysis
```

可以发现共生成对象次数:10481，没有oom异常抛出，并且相对于上次，full gc的数量明显减少了，但是gc时间并没有太大改变

测试1g大小，发生两次full gc,共生成对象次数:15432  

再来测试2g大小，可以选择加上-Xloggc:gc.demo.log 使日志详情输出到当前目录的log文件中

发现此次没有full gc,共生成对象次数:14817 gc 时间明显高于前两次，大概是前两次的两倍多

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -Xms2g -Xmx2g -XX:+UseSerialGC GCLogAnalysis
```

测试4g大小共生成对象次数:16983 4次gc,大多耗时70多ms

测试8g大小共生成对象次数:12770 1次gc 耗时113ms

## 并行垃圾回收

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms512m -Xmx512m -XX:+UseParallelGC GCLogAnalysis
```

共生成对象次数:8939,young gc 时间大概在5ms-9ms,期间发生了几次full gc 时间大概在40ms-50ms之间

```
改为-Xms1g -Xmx1g时候
```

共生成对象次数:16205，full gc总共发生了两次，相比上次明显减少了，young gc相比上次没有明显变化，在9ms左右

```
改为-Xms2g -Xmx2g时候
```

共生成对象次数:17966,，没有发生full gc ，young gc 时间明显增加，大多在29ms

```
改为-Xms4g -Xmx4g时候
```

共生成对象次数:19691,没有发生full gc，young gc时间继续增加，大多在45ms左右，但gc次数相比上次减半

```
改为-Xms8g -Xmx8g时候
```

共生成对象次数:14898,相比上次有所减少，没有发生full gc,只发生一次gc,young gc时间为60ms

## CMS垃圾回收

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms512m -Xmx512m -XX:+UseConcMarkSweepGC GCLogAnalysis
```

共生成对象次数:11817,young gc 时间大概在18ms左右 ，  老年代Initial Mark到Final Remark之间可能会发生1次到多次young gc, Initial Mark和Final Remark中断时间都非常段，不足1ms

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC GCLogAnalysis
```

共生成对象次数:14820,young gc 时间大概在 30-35ms,触发full gc 两次。full gc平均用时45ms

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -Xms2g -Xmx2g -XX:+UseConcMarkSweepGC GCLogAnalysis
```

共生成对象次数:17365,young gc时间大概在50-60ms,没有触发full gc 

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -Xms4g -Xmx4g -XX:+UseConcMarkSweepGC GCLogAnalysis
```

共生成对象次数:16995,gc次数明显减少，没有发生full gc,young gc时间大概在50-60ms

```
java -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xms8g -Xmx8g -XX:+UseConcMarkSweepGC GCLogAnalysis
```

共生成对象次数:16489,young gc时间大概在 60ms浮动

## G1垃圾回收

```
java -XX:+PrintGC -XX:+PrintGCDateStamps  -Xms256m -Xmx256m -XX:+UseG1GC GCLogAnalysis
```

发生oom异常，7次full gc

```
 java -XX:+PrintGC -XX:+PrintGCDateStamps   -Xms512m -Xmx512m -XX:+UseG1GC GCLogAnalysis
```

共生成对象次数:11685 gc时间很小2-5ms, 次数较多200多次

```
java -XX:+PrintGC -XX:+PrintGCDateStamps   -Xms1g -Xmx1g -XX:+UseG1GC GCLogAnalysis
```

共生成对象次数:18377 gc次数达 70次左右

```
java -XX:+PrintGC -XX:+PrintGCDateStamps   -Xms2g -Xmx2g -XX:+UseG1GC GCLogAnalysis
```

共生成对象次数:18257  gc次数达 20次左右

````
java -XX:+PrintGC -XX:+PrintGCDateStamps   -Xms4g -Xmx4g -XX:+UseG1GC GCLogAnalysis
````

共生成对象次数:20254   只剩下 (G1 Evacuation Pause) (young) 次数15次 gc时间10-15ms左右

````
java -XX:+PrintGC -XX:+PrintGCDateStamps   -Xms8g -Xmx8g -XX:+UseG1GC GCLogAnalysis
````

共生成对象次数:20958  只剩下 (G1 Evacuation Pause) (young) 次数13次 gc时间18ms左右



总结

1.由于设置xms,xmx过小， 导致频繁触发young gc 和 full gc， oom异常发生；

2.xms,xmx不是设置越大越好，像串行，并行，CMS设置过大，产生对象数量反而下降，业务执行效率不高，但是gc次数会随着xms,xmx值设置变大而减少

3.CMS GC 是老生代适用。减少停顿，以响应时间为优先。只有标记和清除，不会进行会压缩。测试显示发生5五次youngGC后，就进行CMS GC

4.如果系统内存堆较大，推荐使用G1,内存越大的情况下 G1 回收的效率越高，gc时间相比其他垃圾回收器要短





